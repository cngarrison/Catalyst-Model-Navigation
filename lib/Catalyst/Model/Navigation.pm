package Catalyst::Model::Navigation;
# ABSTRACT: Create HTML::Navigation model, populate with action attributes, CMS pages, and app config

use v5.16;
use Moose;
# use MooseX::ClassAttribute;
use namespace::autoclean;

# extends "Catalyst::Model::Adaptor";
# extends "Catalyst::Model::Factory::PerRequest";
extends "Catalyst::Model::Factory";

use Scalar::Util qw(weaken);
use CNG::Log::Contextual;
use Data::Printer;


# VERSION: generated by DZP::OurPkgVersion

has "action_menu_items" => (
	is      => "rw",
	isa     => "HashRef",
	traits  => ['Hash'],
	default => sub { {} },
	handles => {
		get_action_menu_item      => 'get',
		get_all_action_menu_items => 'values',
		set_action_menu_item      => 'set',
		has_action_menu_items     => 'count',
		has_no_action_menu_items  => 'is_empty',
		clear_action_menu_items   => 'clear',
	},
);

has "menus" => (
	is      => "rw",
	isa     => "HashRef[HashRef]",
	traits  => ['Hash'],
	default => sub { {} },
	handles => {
		get_menu       => 'get',
		get_menu_paths => 'keys',
		get_all_menus  => 'values',
		set_menus      => 'set',
		has_menus      => 'count',
		has_no_menus   => 'is_empty',
		clear_menus    => 'clear',
	},
);


__PACKAGE__->config(
	class => "HTML::Navigation",
	args  => {
		no_sorting => 0,
	},
);


sub prepare_arguments {
# 	my ($self, $app) = @_; # $app sometimes written as $c
# 	my ( $self, $c ) = @_;    # $better written as $c for Factory::PerRequest
	my $self = shift;
	my $c    = shift;
	my $args = $self->next::method( $c, @_ );
# 	log_debug { "Preparing ARGUMENTS with: " . p($args) };

	##  MenuBar#MenuLabel#SubMenuLabel  -vs-  #MenuLabel#SubMenuLabel (default menu bar)
	my $menu_name = delete $args->{menu_name};    # Members, Admin, Developer, Footer
	$menu_name ||= '#';
# 	log_debug { "Preparing ARGUMENTS for $menu_name" };
	return {
		%{$args},
		items => $self->action_items( $c, $menu_name ),
# 		items => $self->cms_items($c, $menu_name),
	};
} ## end sub prepare_arguments


sub action_items {
	my $self      = shift;
	my $c         = shift;
	my $menu_name = shift;

# 	log_debug { "Getting NAV ITEMS for $menu_name" };
	if ( $self->has_no_action_menu_items ) {
# 		log_debug { "Creating NAV ITEMS" };
		my $dispatcher = $c->dispatcher;

		foreach my $c_name ( $c->controllers(qr//) ) {
			my $controller        = $c->controller($c_name);
			my @action_containers = $dispatcher->get_containers( $controller->action_namespace($c) );
			#$c->log->debug("Looking at Controller $c_name for navigation entries") if $c->debug;

# 			my @container_parts = map { $_->part } @action_containers;
# 			log_debug { "Got ACTIONS for $c_name: " . p(@container_parts) };
# 			foreach my $action_container (@action_containers) {
			my $action_container = $action_containers[-1];
			my $actions          = $action_container->actions;
			foreach my $key ( keys(%$actions) ) {
				my $action = $actions->{$key};
				if ( $action->attributes->{Menu} ) {
					$self->add_action_menu_item( $c, $action, $controller );
				}

			}
# 			} ## end foreach my $action_container (@action_containers)
		} ## end foreach my $c_name ( $c->controllers(...))
	} ## end if ( $self->has_no_action_menu_items)

# 	my $menus = $self->menus;
# 	log_debug { "Value of menus is: " . p($menus) };

	my @am_items = sort { $a->{menu_parent} cmp $b->{menu_parent} }
	  grep { $_->{menu_parent} =~ m/^$menu_name/ } $self->get_all_action_menu_items;

# 	log_debug { "Value of am_items is: " . p(@am_items) };
# 	log_debug { "===============================================================================" };

	my @nav_items;
	foreach my $am_item (@am_items) {
		my $m_parent = $am_item->{menu_parent};
		$m_parent =~ s/^([^#]*)(#.*)/$2/;

		my @sub_menus = split( '#', $m_parent );
		shift @sub_menus unless $sub_menus[0];
# 		log_debug { "Use $m_parent to split sub_menus: " . p(@sub_menus) };

		my $last_menu;
		if ( scalar @sub_menus >= 1 ) {    # count of items, not last index
			my $multi_nav_items = \@nav_items;    # grab copy of 'root level' menu nav items
# 			log_debug { "Have menu(s) to add for $m_parent, to existing multi_nav_items: " . p($multi_nav_items) };
			my $parent_menu;
			for ( my $i = 0; $i <= $#sub_menus; $i++ ) {

				my $menu_path = $sub_menus[$i];

# 				log_debug { "Searching multi_nav_items for: " . $menu_path };
				my ($nav_item) = grep { $_->{path} eq $menu_path && defined $_->{children} } @$multi_nav_items;
				if ( !$nav_item ) {

# 					log_debug { "Creating new sub_menu for: " . $am_item->{menu_parent} . " using path: " . $menu_path };
					my $menu = $self->get_menu( $am_item->{menu_parent} );
					$nav_item = {
						path        => $menu_path,
						order       => $menu->{order},
						label       => $menu->{label} || $menu_path,
						title       => $menu->{title},
						css_classes => $menu->{css_classes},
						dom_id      => $menu->{dom_id},
						children    => [],
					};

					push( @$multi_nav_items, $nav_item );
# 					log_debug { "Added new sub_menu for: " . p($nav_item) . " to multi_nav_items: " . p($multi_nav_items) };
				} ## end if ( !$nav_item )

				$last_menu = $parent_menu = $nav_item;
				$multi_nav_items = $nav_item->{children};    # grab copy of 'current level' menu nav items
			} ## end for ( my $i = 0; $i <= $#sub_menus...)

			push( @{ $last_menu->{children} }, $am_item );
# 			log_debug { "Pushed: " . $am_item->{menu_parent} . " with path: " . $last_menu->{path} . " to multi_nav_items: " . p( $last_menu->{children} ) };

		} else {
			## top-level link, no menu
			push( @nav_items, $am_item );

		}
	} ## end foreach my $am_item (@am_items)

# 	log_debug { "Value of nav_items is: " . p(@nav_items) };

	return [@nav_items];
# 	return [grep { $_->{menu_parent} =~ m/^$menu_name/ } $self->get_all_action_menu_items];
# 	return [$self->get_all_action_menu_items];
} ## end sub action_items

sub add_action_menu_item {
	my ( $self, $c, $action, $controller ) = @_;

	my $action_key = $action->namespace . '/' . $action->name;
	return if $self->get_action_menu_item($action_key);

# 	$c->log->debug( sprintf( "Adding action item for path: %s with parent: %s in controller: %s", $action_key, $action->attributes->{MenuParent}->[0] || '', ref $controller ) ) if $c->debug;
	# Create the items needed to build the item.
	my $menu_parents =
	  defined $action->attributes->{MenuParent} && scalar @{ $action->attributes->{MenuParent} } > 0
	  ? $action->attributes->{MenuParent}
	  : ['#'];

# 	$c->log->debug( sprintf( "Action details: \nclass: %s\nnamespace: %s\nreverse: %s\nprivate_path: %s", $action->class, $action->namespace, $action->reverse, $action->private_path ) ) if $c->debug;
# 	log_debug { "Value of menu_parents is: " . p($menu_parents) };

	my $c_nav_config   = $c->config->{navigation}          || {};
	my $ctr_nav_config = $controller->config->{navigation} || {};
	
	my $last_item = {};
	for ( my $i = 0; $i <= $#$menu_parents; $i++ ) {
		my $mp = $menu_parents->[$i];
		# does parent contain a hash
		$mp = $mp . '#' unless $mp =~ /#/;
		my $action_attrs = $action->attributes;
		
		my $conditions = $action_attrs->{MenuCond} || [];
		if ( scalar @$conditions == 0 ) {
			my $role_attr = $action_attrs->{MenuRoles}->[$i] || $last_item->{required_roles} || '';
			if ($role_attr) {
				my @roles_and = split( ',', $role_attr );
				# Check each required role.
				foreach my $role (@roles_and) {
					push(
						@$conditions,
						sub {
							my $ctx = shift;
							return undef unless $ctx;
							if ( $ctx->can('check_user_roles') ) {
								if ( $role =~ /\|/ ) {
									my @roles = split( /\|/, $role );
									return $ctx->check_any_user_role(@roles) ? 1 : 0;
								} else {
									return $ctx->check_user_roles($role) ? 1 : 0;
								}
							} ## end if ( $ctx->can('check_user_roles'...))
						}
					);
				} ## end foreach my $role (@roles_and)
			} ## end if ($role_attr)
		} ## end if ( scalar @$conditions == 0 )

		my $item = {
			menu_parent    => $mp,
			path           => $action_key,
			url            => $c->uri_for_action( $action, $action_attrs->{MenuArgs} || [] ), ##$self->_build_url_coderef($c, $action),
			order          => $action_attrs->{MenuOrder}->[$i] || $last_item->{order} || 0,
			label          => $action_attrs->{Menu}->[$i] || $last_item->{label} || '',
			title          => $action_attrs->{MenuTitle}->[$i] || $last_item->{title} || '',
			required_roles => $action_attrs->{MenuRoles}->[$i] || $last_item->{required_roles} || '',
			conditions     => $conditions,
		};

		$last_item = $item;
		$self->set_action_menu_item( sprintf( '%s#%s', $mp, $action_key ), $item );
		if ( $mp && !$self->get_menu($mp) ) {
			$self->set_menus(
				$mp, {
					path        => $c_nav_config->{$mp}->{path}        || $ctr_nav_config->{$mp}->{path}        || $action_attrs->{MenuParentPath}->[0]  || '',
					order       => $c_nav_config->{$mp}->{order}       || $ctr_nav_config->{$mp}->{order}       || $action_attrs->{MenuParentOrder}->[0] || 0,
					label       => $c_nav_config->{$mp}->{label}       || $ctr_nav_config->{$mp}->{label}       || $action_attrs->{MenuParentLabel}->[0] || '',
					title       => $c_nav_config->{$mp}->{title}       || $ctr_nav_config->{$mp}->{title}       || $action_attrs->{MenuParentTitle}->[0] || '',
					css_classes => $c_nav_config->{$mp}->{css_classes} || $ctr_nav_config->{$mp}->{css_classes} || $action_attrs->{MenuParentCssClasses} || [],
					dom_id      => $c_nav_config->{$mp}->{dom_id}      || $ctr_nav_config->{$mp}->{dom_id}      || $action_attrs->{MenuParentDomId}->[0] || '',
				}
			);

		} ## end if ( $mp && !$self->get_menu($mp...))
	} ## end for ( my $i = 0; $i <= $#$menu_parents...)
} ## end sub add_action_menu_item



sub _build_url_coderef {
	my ( $self, $c, $action, @action_args ) = @_;
	my $weak_ctx = $c;
	weaken $weak_ctx;
	my $sub = sub {
		$weak_ctx->uri_for_action( $action, [@action_args] );    # $self was leaking
	};
	return $sub;


} ## end sub _build_url_coderef


__PACKAGE__->meta->make_immutable;


1;

